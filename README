                         ===========================
                         repay: efficient repayments
                         ===========================

    Repay is a simple tool which computes the most efficient way for everyone
    to repay their debts.  You feed it a list of historical transactions:

        { "from":"Jane", "to":"Fred", "amt":7200 }
        { "from":"Rémy", "to":"Alex", "amt":7300 }
        { "from":"Fred", "to":"Mike", "amt":7800 }
        { "from":"Fred", "to":"Mike", "amt":4500 }
        { "from":"Mike", "to":"Alex", "amt":5600 }
        { "from":"Jane", "to":"Fred", "amt":9300 }
        { "from":"Mike", "to":"Rémy", "amt":6100 }
        { "from":"Alex", "to":"Jane", "amt":2400 }
        { "from":"Mike", "to":"Jane", "amt":6400 }
        { "from":"Jane", "to":"Rémy", "amt":9300 }

    And it spits out a minimal list of transactions which will make everyone
    square:

        { "from":"Fred", "to":"Mike", "amt":4200 }
        { "from":"Rémy", "to":"Jane", "amt":8100 }
        { "from":"Alex", "to":"Mike", "amt":1600 }
        { "from":"Alex", "to":"Jane", "amt":8900 }

USAGE

    repay [-x|-a] <PATH>

        -x        Guarantees a minimal solution (see EXACT MODE below)
        -a        Use a faster algorithm (see APPROXIMATE MODE below)
        <PATH>    The ledger containing historical transactions

INSTALLATION

    Repay is written in Rust.  Install it using cargo:

        cargo install --git https://github.com/asayers/repay.git

INPUT FORMAT

    As you can see, transactions are newline-delimited JSON objects.  The input
    transactions may contain additional fields which repay will ignore:

        { "date":"2018-02-17", "from":"Jane", "to":"Fred", "amt":7200, "rsn":"Paid for lunch" }
        { "date":"2018-02-19", "from":"Rémy", "to":"Alex", "amt":7300, "rsn":"Bet on football" }
        { "date":"2018-02-19", "from":"Fred", "to":"Mike", "amt":7800, "rsn":"Undisclosed" }
        { "date":"2018-02-20", "from":"Jane", "to":"Fred", "amt":9300, "rsn":"Delivery man" }
        { "date":"2018-02-19", "from":"Alex", "to":"Rémy", "amt":7300, "rsn":"Settlement" }

    The output will still only contain "from", "to", and "amt", however.  The
    overhead should be minimal, so feel free to go crazy:

        { "from":"Mike", "to":"Jane", "amt":6400,
          "sig":"RWS1l0sm+eG0IZ7/JZ7V3Ct584XleF33BQkIiXmHNHjHKWTBZprpVPeiLsCpkRFL1m0y3z7xFBkxnzoNVbTELwB932C1rdllJwQ=" }

    Note that all amounts must be integers - "amt":2.50 will cause an error -
    so you'll probably want to record all amounts in a small currency like
    cents or pence or yen.

PERFORMANCE CONSIDERATIONS

    The time taken to parse the ledger is linear in its length.  On my machine,
    a million entries takes ~30s to parse.  If this becomes a problem, you
    might consider compacting your ledger.  (You can do this by running repay,
    negating all the amounts, and using this as the start of your new ledger.)

    In exact mode, solving time scales exponentially with the number of people
    involved.  Things can get bad very quickly:  on my machine, a ledger
    mentioning 16 people takes ~30s to solve;  with 17 people it takes ~4m.  If
    you have lots of people with interconnected debts, you're stuck using
    approximate mode.

    In approximate mode, solving time scales with the total amount of debt (ie.
    the abs-sum of everyone's balances).  This shouldn't be a problem in
    practice.

APPROXIMATE MODE

    We have a multiset of integers, representing people's outstanding balances.
    We draw edges from the positive nodes to the negative nodes (forming a
    biclique).  We then solve for minimum-cost-maximum-flow, where the cost of
    each edge is the same.  The non-zero edges, and the amount which flows
    across them, form our repayment plan.

    In some cases, this algorithm will yield a plan with too many repayments:

        $ repay ledger_22 -v
         INFO: Read 22 entries from ledger_22 in 0.000s
         INFO: 18 unresolved balances, 35818 to repay
         INFO: Computed repayment plan in 0.000s: 16 repayments required
        [snip]

        $ repay ledger_22 -v -x
         INFO: Read 22 entries from ledger_22 in 0.000s
         INFO: 18 unresolved balances, 35818 to repay
         INFO: Computed repayment plan in 0.043s: 9 repayments required
        [snip]

    Unfortunately, there's no efficient way to tell whether an approximate
    repayment plan is optimal or not;  computing the size of the optimal plan
    is just as hard as computing the plan itself.

EXACT MODE

    For an arbitrary multiset, you will need between n/2 and (n-1) edges to
    facilitate a complete flow.  Our task is to minimise the number of edges,
    without reducing the total flow.

    This problem is equivalent to the "maximal zero-sum partitioning" (MZSP)
    problem:

    > Given a multiset of integers X, such that ∑(X)=0, partition X into the
    > maximum number of subsets so that every subset also sums to zero.

    Why is it equivalent?  If you partition your original multiset into
    zero-sum subsets, you can independently draw a graph for each subset - a
    graph containing at most n-1 edges.  Therefore, if you can form m subsets
    then you can bring the number of edges in the combined graph down to n-m.

    Suppose there is a solution with n-m edges; then there must exist a
    partitioning with m zero-sum subsets.  (TODO: prove)

    Therefore, if you find a MZSP, and for each partition you construct a
    flow-maximising graph, then the combined graph must be optimal.

    Given a zero-sum multiset, a flow-maximising graph with n-1 edges can be
    constructed in O(n).  This means that the real problem is finding the MZSP.

    repay's implementation of MZSP is O(3^n).  This is painful, but given that
    MZSP is NP-hard, I don't expect it's possible to do much better.  The
    algorithm we use is due to Akio Takano.

    See also:

     * https://en.wikipedia.org/wiki/Subset_sum_problem
     * https://math.stackexchange.com/questions/339148/maximal-zero-sums-partition

LICENCE

    Licensed under either of the following, at your option:

     * Apache Licence 2.0 (see LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0)
     * MIT licence (see LICENSE-MIT or http://opensource.org/licenses/MIT)

    Unless you explicitly state otherwise, any contribution intentionally
    submitted for inclusion in the work by you, as defined in the Apache-2.0
    license, shall be dual licensed as above, without any additional terms or
    conditions.
